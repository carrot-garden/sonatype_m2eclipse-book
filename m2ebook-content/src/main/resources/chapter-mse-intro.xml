<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.sonatype.com/tmp/docbook/xml/4.5/docbookx.dtd">
<chapter id="mse-intro">
  <title>Introduction to Maven Studio for Eclipse</title>

  <section id="mse-intro-sect-intro">
    <title>Introduction</title>

    <para>Maven Studio for Eclipse currently provides Developer Onboarding, a
    feature fully introduced and defined in <xref
    linkend="mse-intro-devonboard" />. For more information about Maven Studio
    for Eclipse, please contact <ulink
    url="mailto:info@sonatype.com">info@sonatype.com</ulink>.</para>
  </section>

  <section id="mse-intro-devonboard">
    <title>Developer Onboarding</title>

    <para>Developer Onboarding can be defined as the process of bringing a
    developer "onboard" a particular development project. This process usually
    encompasses setting up the tools used during development - an Integrated
    Development Environments, compilers, and other tools used to design,
    write, test, debug, and deploy code. This section describes some of the
    challenges involved in Developer Onboarding, and provides some context for
    the Developer Onboarding feature now available in Maven Studio for
    Eclipse.</para>

    <section>
      <title>The Cost of New Developer Onboarding</title>

      <para>On average, it typically takes a new developer five days before
      they can start contributing to a project. During this 5-day period, a
      developer will complete the tasks described below and illustrated in
      <xref linkend="fig-mse-manual-onboard" />:</para>

      <variablelist>
        <varlistentry>
          <term>Day 1 Workstation Setup</term>

          <listitem>
            <para>Setup a workstation, install baseline requirements such as a
            Java Development Kit and other languages or fundamental
            frameworks.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Day 2 Downloading Components</term>

          <listitem>
            <para>Download all of the components required for a development
            environment, this often includes components like:</para>

            <itemizedlist>
              <listitem>
                <para>Source Control tools (Subversion, Git, Clearcase, or
                CVS)</para>
              </listitem>

              <listitem>
                <para>Integrated Development Environments (Eclipse IDE)</para>
              </listitem>

              <listitem>
                <para>Automated Testing Tools (Selenium)</para>
              </listitem>

              <listitem>
                <para>Application Servers / Containers (Websphere, Jetty,
                Tomcat)</para>
              </listitem>

              <listitem>
                <para>Build Tools (Maven, Ant)</para>
              </listitem>

              <listitem>
                <para>Databases (Oracle, MySQL, SQL Server)</para>
              </listitem>

              <listitem>
                <para>Scripting Languages (Ruby, Python, Perl)</para>
              </listitem>

              <listitem>
                <para>General Utilities (cygwin, emacs, other
                utilities)</para>
              </listitem>
            </itemizedlist>

            <para>The best-case scenario is an organization which maintains a
            detailed list of software components required in a development
            environment. In most organizations this information isn't firmly
            fixed in time as different developers set up environments as they
            are introduced to a project. New programmers will often notice a
            slight variation in the versions of components used by other
            programmers in the same group. Example: a senior developer who has
            been on the team for years might still use Eclipse 3.4, while
            newer developers might just download the latest version of Eclipse
            3.5.1.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Day 2 Self-directed Learning</term>

          <listitem>
            <para>Developers not directly familiar with tools like Maven will
            need to learn how to install and configure these tools. Most new
            developers spend at least half a day familiarizing themselves with
            the installation and configuration process for new development
            infrastructure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Day 3 Installing Software</term>

          <listitem>
            <para>Once all of the required software has been downloaded, it
            must be installed and configured. Eclipse must be installed and
            configured, a local testing database must be configured, the IDE
            settings must be customized to account for specific standards used
            by the organization.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Day 3 Ad-hoc Training</term>

          <listitem>
            <para>After setting up and environment, a developer will usually
            require the assistance of other members of the development team.
            Ad-hoc training sessions will involve other developers
            communicating standards and software: "Have you used JUnit before?
            This is how we run a unit test."</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Day 4 Source Code</term>

          <listitem>
            <para>It is just at Day 4 that a developer starts to think about
            accessing source code. More dicussions with members of the same
            group about source code are usually accompanied by an overview of
            the various source control systems and structure of the various
            groups. Checking out source code is as much about learning about
            the organizational structure of a code base as it is about
            learning how that code maps to project groups. Who is responsible
            for various components, how is the source checked out of source
            control, and how often is it updated.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Day 4 Build System</term>

          <listitem>
            <para>Once the code is properly checked out and imported into your
            IDE, a developer will need to build an entire system. If the
            organization has already standardized on a tool like Apache Maven,
            this could be as simple as typing in "mvn clean install" at the
            command prompt. Most organizations require some level of
            customization for a build to work properly. Whether this means
            that a developer needs to fully understand a custom Ant build or
            just find out how to configure Maven settings to connect to a
            Nexus repository, there is usually some work involved in figuring
            out how the build works and how it should be configured
            properly.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Day 5 Configuring Development Environment</term>

          <listitem>
            <para>Once a developer can build the code, the next step is to
            configure a local development environment. If a developer is
            working on an enterprise application, this may involve setting up
            a local instance of a database and populating that database with
            test data.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Day 5 Integrating 3rd Party Projects</term>

          <listitem>
            <para>If an enterprise application depends on 3rd-party open
            source projects, a developer will often checkout relevant source
            code from open source projects and configure them alongside the
            development environment for internal code.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <figure id="fig-mse-manual-onboard">
        <title>A Representative 5-Day, Manual Onboarding</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata contentdepth="100%"
                       fileref="figs/web/mse-first-week.png" scalefit="1" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center" fileref="figs/print/mse-first-week.pdf"
                       scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Onboarding with Maven Studio for Eclipse: Productive on Day
      One</title>

      <para>With Maven Studio for Eclipse, a build engineer can capture all of
      the components required for a development environment in an MSE
      Codebase. This MSE Codebase is then published to Nexus Team edition and
      is downloaded by a developer in a process called "Materialization". When
      a developer materializes an MSE Codebase, a component called the MSE
      Installer downloads an XML descriptor which captures all of the
      configuration parameters for a completely customized build
      environment.</para>

      <para><xref linkend="fig-mse-minimum-onboard" /> shows the process from
      <xref linkend="fig-mse-manual-onboard" /> condensed into a single day. A
      developer's first day on the job is still characterized by
      introductions, tours, and meetings, but instead of relegating a
      developer to a week of manual installation and configuration tasks, a
      developer simply clicks on a link to materialize an MSE Codebase. An MSE
      Codebase can be materialized in a few minutes, and once this process is
      done, a new developer can be productive on Day One.</para>

      <figure id="fig-mse-minimum-onboard">
        <title>Minimizing Onboarding Time with Maven Studio for
        Eclipse</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata contentdepth="100%"
                       fileref="figs/web/mse-first-week-good.png" scalefit="1" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/mse-first-week-good.pdf"
                       scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>The ramifications of this easy setup process are more than just
      time saved and efficiencies gained. When it only takes a new developer a
      few minutes to get his or her workstation setup, they can take more time
      in the first days to learn about projects and architecture. They can
      start to engage a group socially, participating in development
      discussions and decisions instead of disappearing into a cave to install
      software.</para>

      <para>This new ability to get prouctive quickly also changes the way in
      which developers are added to a project. When you know it will only take
      a few minutes to install a development environment, checkout all
      required source code, and configure a build, you won't have to build in
      a week of downtime into your schedule for new developers. If your
      project needs the help, you can hire a new developer to make focused
      changes without having to sacrifice five days of time to inefficient
      manual setup.</para>

      <para>Maven Studio for Eclipse makes your organization more agile, more
      efficient. Increased efficiencies do more than save time and resources.
      They change the dynamics of the group and make it possible to focus more
      on your application's code and less on the tools required to build
      it.</para>
    </section>

    <section>
      <title>Managing Developer Workspace Complexity</title>

      <para>Developers spend most of their time connecting components within a
      development environment to one another. As open source software tools
      and components have created a wealth of choices, these tools have also
      increased the cognitive burden on software developers. Gone are the days
      when a developer could simply install Java, Eclipse, and Maven and just
      start to code. In today's software development environment, a developer
      needs to not only configure an IDE, she needs to connect that IDE to a
      collection of infrastructure resources like JIRA and Confluence,
      configure the system to interact with source control, and install any
      number of supporting components.</para>

      <para>As most developers only configure a workstation once or twice a
      year, the true complexity is always somewhat surprising. Developers
      don't realize exactly how much time is wasted on workstation setup until
      they've wasted an entire day downloading and installing the various
      software components involved in an environment. This process is not
      unlike process most Java developer used to use to obtain dependencies
      for a Java project.</para>

      <para>Before the arrival of Maven, a software developer had to manually
      download and configure a set of libraries, a set of dependencies. Maven
      Studio for Eclipse takes one of the central ideas of Maven, the idea
      that you can describe your project and let Maven take care of
      downloading components from a central repository, and it applies this
      concept to your development environment. Instead of asking your
      developers to download, configure, and connect an increasing number of
      components. Use Maven Studio, capture your development environment in a
      descriptive codebase, and let Maven Studio for Eclipse take care of the
      details.</para>

      <figure id="fig-mse-component-explosion">
        <title>Consolidating Complexity into Eclipse IDE</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata contentdepth="100%"
                       fileref="figs/web/wordle-compare.png" scalefit="1" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center" fileref="figs/print/wordle-compare.pdf"
                       scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>Managing Change in Development Environments</title>

    <para>When you use Maven Studio for Eclipse Developer Onboarding, and you
    standard your entire development team's environment on managed Eclipse
    codebases, you start to decrease the amount of time, the amount of
    investment necessary to update and maintain your development environment.
    Once you've created a system that allows you to redeploy a new development
    environment over hundreds of workstations in a few hours, you've
    implemented low-risk, or "disposable" development environments. The cost
    to change your developer's environments is small enough that you can start
    making changes without having to worry about the logistics of such a
    change.</para>

    <para>To illustrate the benefits of low-risk, or "disposable" development
    environments consider the ongoing invest of time and effort to keep a
    development environment up to date. The follow two examples illustrate the
    differences between using high-risk, high-investment development
    environments, and low-risk, "disposable" development environments.</para>

    <section>
      <title>The Common Scenario: Upgrading Development Infrastructure</title>

      <para>Consider a average sized workgroup of 20 developers and 5 project
      managers. This team of 20 developers is split up into 4 teams of five
      engineers, and each team works with a project manager to set direction
      and track progress. The product development lifecycle in this particular
      organization is twelve months. From initial product design to testing to
      implementation and lastly final delivery takes, on average about twelve
      months start to finish. Let's also assume that the entire team uses the
      same development environment, the same testing infrastructure, and a
      common approach to tools, releases, and source control.</para>

      <para>At the start of a project development cycle, senior developers
      from each team usually meet to decide upon changes to the development
      tool stack. Questions like: What version of Eclipse are we standardizing
      on? What is the structure of our source code repository? What tools do
      we need to standardize on for testing? All of these questions are
      answered at the beginning of the project, and while developers and
      project managers are working on architecture issues and other plans,
      there is a build engineer or an architect who is tasked with documenting
      a standard set of tools and procedures for development.</para>

      <para>This tools selection and standardization process usually takes two
      weeks to complete. While we are not dealing with new employees, very
      often when a new development stack is introduced, developers and
      managers need to recalibrate knowledge of tools, retrain themselves on
      the latest versions of build systems and IDEs, maybe the organization
      also uses this time period of refresh engineer's laptops. Getting a new
      laptop after two years of working can often introduce as much downtime
      in project schedules as hiring a new employee.</para>

      <para>The point here is that technology management understands that
      there is some downtime at the start of a project to allow the senior
      technical talent to introduce newer approaches technologies into the
      mix. This is commonly accepted practice, and it makes sense to introduce
      risky changes at the beginning of a product lifecycle when there is
      enough time to mitigate any unexpected problems that might be introduced
      by such a change.</para>
    </section>

    <section>
      <title>Disadvantages of a High-Risk Development Environment</title>

      <para>Assume that it takes about two weeks to deliver change to the
      development environment. A new Eclipse-based plugin needs to be
      configured, tested, and delivered to every developer workstations, or
      source control locations needs to be refactored or split. This two weeks
      is not the time it takes for any one developer to implement a change.
      This two week period is the time it takes for build engineers to
      introduce the change, train developers, and then migrate individual
      developer workstations over to a new development environment. In this
      scenario, developers manually build workstations from a set of
      instructions, and each developer also has the potential to install
      different versions on a workstation. The two week period is the length
      of time it takes for most developers to convert and for every developer
      to work out any issues which may arise during an environment
      upgrade.</para>

      <para><xref linkend="fig-mse-intro-high-risk" /> illustrates the
      end-result of having such a high-risk approach to development
      environments. Because the process of deploying change to a development
      environment take two weeks to fully implement, technical managers are
      going to be very careful about introducing any change into the
      environment in the middle of an active product development cycle. If a
      new version of Eclipse is introduced which improves performance, or if a
      new version of Maven is made available that enables greater flexibility,
      managers are not likely to approve any changes.</para>

      <para>The following, fictional dialog captures the reality of a
      development group with a manual, high-risk strategy for testing and
      deploying changes to development infrastructure:</para>

      <blockquote>
        <para>Build Engineer: "They just released a new version of Maven to
        address some of the issues we are having with the Surefire
        plugin."</para>

        <para>Manager: "How long is it going to take to test and deploy this
        fix to 100 developers?"</para>

        <para>Build Engineer: "One week of testing and about a week to deploy
        the changes to every team. We have to wait for people to have enough
        time available to follow our instructions."</para>

        <para>Manager: "If it isn't critical, I'd rather wait until we've
        completed this cycle to implement this change. It doesn't seem worth
        it given the risk that our timelines will be affected."</para>
      </blockquote>

      <figure id="fig-mse-intro-high-risk">
        <title>High-risk Development Environments Discourage Change within
        Constrained Development Cycles</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata contentdepth="100%"
                       fileref="figs/web/high-cost-dev-changes.png"
                       scalefit="1" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/high-cost-dev-changes.pdf"
                       scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>If you work in one of these environments you'll recognize this
      situation. Managers are understandably risk-averse because they know
      that there is no automatic method for deploying changes to development
      environments. Developers are also risk averse because every time the
      build engineers come up with a new idea they lose a substantial amount
      of time following a loosely documented, ad-hoc process for running
      manual updates. In this scenario, the build engineer is often identified
      as the enemy of project stability and the team resists changes to the
      development environment.</para>
    </section>

    <section>
      <title>Advantages of a Low-risk Development Environment</title>

      <para>When an organization has standardized on low-risk, disposable
      development environments using Maven Studio for Eclipse, it takes little
      or no time to redeploy changes across all developer workstations. If the
      department needs to upgrade from Eclipse 3.5.1 to Eclipse 3.6.0 or
      upgrade to a newer version of the m2eclipse plugin, this change can be
      executed in a matter of hours. A build engineer can test a change to a
      development environment, publish a codebase to Nexus Team Edition and
      then send an email to hundreds of developers instructing them to
      materialize the latest codebase. In minutes, every engineer in the group
      can materialize the same development environment. Most importantly, if
      the newly published MSE Codebase has a problem or an issue, developers
      can rull back to a previous version of the published Codebase and
      continue developing.</para>

      <para>This ability to quickly deploy a development environment doesn't
      just save time, it alters the dynamic between the build engineer and the
      project planners. If the build engineer proposes a change to the
      development environment which involves an upgrade to Eclipse or Maven,
      the build engineer can make the case that this change is low-risk. It
      can be implemented in a single day and deployed in minutes to every
      developer. If the proposed change introduces errors, developers can
      rollback.</para>

      <para><xref linkend="fig-mse-low-risk-changes" /> illustrates the new
      dynamic introduced by low-risk changes to development environment. With
      Maven Studio for Eclipse, it doesn't take two weeks to convince your
      developers to upgrade to a new development environment, and project
      managers can no longer object to a simple, repeatable process with a
      guaranteed fallback plan.</para>

      <figure id="fig-mse-low-risk-changes">
        <title>Low-risk Development Environments Enable Greater Flexibility
        within Constrained Development Cycles</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata contentdepth="100%"
                       fileref="figs/web/low-cost-dev-changes.png"
                       scalefit="1" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/low-cost-dev-changes.pdf"
                       scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para><xref linkend="fig-mse-low-risk-changes" /> shows a 12-month
      product development lifecycle with a series of low-risk changes to the
      development environment. Instead of waiting to schedule high-risk
      project downtime for infrastructure changes, you can upgrade your
      development infrastructure whenever you need to. Development doesn't
      have to come to a complete halt when it only takes a few minutes to
      materialize a codebase. If a new version of Eclipse or a critical tool
      from a vendor is updated, you will be able to quickly test and deploy
      this fix across your department wthout having to make the case to
      management to set aside time for the upgrade.</para>

      <para>Maven Studio for Eclipse enables much greater flexibility within
      constrained development cycles because it makes development environment
      "disposable". You don't have to invest everyone's time in the
      installation and upgrade of development infrastructure; do in once, test
      it, publish, and everyone will have a standard environment
      immediately.</para>
    </section>
  </section>

  <section>
    <title>Consolidating Project Feeds</title>

    <para>Developing good software is a very social activity. For people not
    directly involved in a development effort, this is not immediately
    obvious. If you don't spend your time programming, you might just think
    developers are doing nothing more than staring at Eclipse twelve hours a
    day and communicating with each other using terse, cryptic Subversion
    commit messages. In reality, good developers are constantly interacting on
    IRC, using Issue Trackers such as JIRA, having heated debates on mailing
    lists, and using other means of communication. If your development group
    involves open source, developers working on open source are communicating
    to large groups of volunteers over public channels such as Twitter and
    GitHub.</para>

    <para>Maven Studio for Eclipse provides a mechanism for aggregating feeds
    for a Source Tree. You can use this mechanism as an opportunity to make
    sure that developers working on a particular system are following the
    right feeds. Think of feed support in the MSE product like having a
    project specific feedreader that you can configure, distribute, and
    update. In this industry, information is of primary importance and making
    sure that your developers are keeping up to date on the ever increasing
    number of technologies they need to know is important. With Maven Studio
    for Eclipse, you gain the ability to make sure that developers are paying
    attention to the right pieces of information.</para>

    <section>
      <title>Simple Scenario: Aggregating a Project's Feeds</title>

      <para>If your team is tracking project progress using Atlassian's JIRA
      issue tracker, collaborating on documentation using Atlassian's
      Confluence wiki, changing source code stored in Subversion, monitoring
      production systems using Nagios, tracking builds using Hudson, and
      dscussing strategy using services like Twitter, all of these channels
      create a constant stream of events and which help developers track
      activity.</para>

      <para><xref linkend="fig-mse-aggregating-single" /> illustrates how
      Maven Studio for Eclipse Source Trees can be used to aggregate this
      information into a simple project activity feed presented in the Eclipse
      IDE. Without Maven Studio for Eclipse, this aggregated feed is something
      a developer has to fetch himself. When a new piece of development
      infrastructure such as JIRA or Subversion is added to a project, a
      developer has to figure out how to integrate any available activity
      streams into his personal feed reader. Usually this means that every bit
      of development infrastructure involved in the development effort is
      configured to push automated emails to developer.</para>

      <para>While this strategy of constantly flooding each developer with
      activity emails accomplishes the job, it also ignores the fact that
      every piece of development infrastructure provides support for common
      feed standards such as RSS and Atom. Maven Studio for Eclipse integrates
      with these feed standards and it gives build engineers a standard
      mechanism to make sure that every developer is paying attention to the
      same set of valuable feeds. If you've installed a new source control
      system, or a new tool like Sonar which generates a useful RSS feed, just
      update the codebase, publish it to Nexus Team Edition, and tell your
      developers to materialize the latest version of a codebase. In minutes,
      you can make sure that everyone is paying attention to the same activity
      stream within Eclipse.</para>

      <figure id="fig-mse-aggregating-single">
        <title>Aggregating a Single Project's Feeds</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata contentdepth="100%"
                       fileref="figs/web/codebases-sourcetree-feeds.png"
                       scalefit="1" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/codebases-sourcetree-feeds.pdf"
                       scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Complex Scenarios: Mixed Open/Commercial Development</title>

      <para>A increasingly common scenario in enteprise development is the
      hybrid open source/commercial development effort. Companies large and
      small are starting to build systems to expose an open source core or API
      to the public which relates to a commercial product or commercial
      extension. Sonatype's Nexus repository manager is just such a project.
      Nexus Open Source has a large, vibrant development community that
      includes many developers not directly employed by Sonatype. Nexus
      Professional has a smaller team of programmers who are all directly
      employed by Sonatype.</para>

      <para>Another common scenario is a company which develops a complex
      enterprise system which relies heavily on customized open source
      components. Companies like Google develop large, proprietary codebases
      for cloud computing while making massive, continued contributions to the
      open source projects it depends on. In these scenarios, you may
      configure an MSE Codebase with two source trees, one proprietary source
      tree pointing to your own, private source code repository, and another
      source tree pointing to a public, open-source repository.</para>

      <para>In the scenario of a mixed, open/commercial development effort,
      you can configure the Open Source source tree to track public
      components: public issue trackers, twitter accounts of the main
      contributors, public mailling lists, and you can configure the
      Commercial source tree to track private activity logs from internal
      issue trackers and source code control systems. Developers will then see
      a unified view of project activity. They can keep up with the critical,
      open-source projects that the system depends on and they can keep track
      of internal activity.</para>

      <figure id="fig-mse-multi-agg">
        <title>Aggregating Multiple Project's Feeds</title>

        <mediaobject>
          <imageobject role="web">
            <imagedata contentdepth="100%"
                       fileref="figs/web/codebases-sourcetree-mixed-feeds.png"
                       scalefit="1" />
          </imageobject>

          <imageobject role="print">
            <imagedata align="center"
                       fileref="figs/print/codebases-sourcetree-mixed-feeds.pdf"
                       scalefit="0" width="100%" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>
</chapter>
